<!DOCTYPE html>
<html lang="">


<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>
    cpu上下文切换 | 技术杂谈
  </title>
  <meta name="description" content="Talk is cheap,Show me the code.">
  
  <meta name="keywords" content="
  cpu 上下文切换
  ">
  
  <meta name="author" content="tudou">

  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

  <link rel="icon" type="image/x-icon" href="">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  

  

  <script src="//cdnjs.cloudflare.com/ajax/libs/vue/1.0.25-csp/vue.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.11.2/moment.min.js"></script>
</head>

<body id="replica-app">

<nav class="navbar-wrapper">
  <div class="navbar">
    <div class="container clearfix">
      <a href="/" class="navbar-logo"><i class="fa fa-github"></i></a>

      <div class="navbar-search float-left desktop-only">
        <div class="navbar-search-form">
          <label for="gsc-i-id1">This website</label>
          <div id="google-search">
            <gcse:search></gcse:search>
          </div>
        </div>
      </div>

      <ul class="navbar-nav float-left">
        
        <li><a href="/archives">Archives</a></li>
        
        
        <li><a href="/categories">Categories</a></li>
        
        
        <li><a href="/tags">Tags</a></li>
        
        
        <li class="desktop-only"><a href="/atom.xml" target="_blank">RSS</a></li>
        
      </ul>

      <ul class="navbar-nav user-nav float-right desktop-only">
        <li class="user-nav-notification">
          <a><span class="user-nav-unread"></span><i class="fa fa-bell"></i></a>
        </li>
        <li>
          <a><i class="fa fa-plus"></i> <i class="fa fa-caret-down"></i></a>
        </li>
        <li class="user-nav-logo">
          <a><img src="https://octodex.github.com/images/baracktocat.jpg"> <i class="fa fa-caret-down"></i></a>
        </li>
      </ul>
    </div>
  </div>
</nav>

<div class="main-container">
  <header class="header-wrapper desktop-only">
  <div class="container header-site-detail">
    <ul class="header-toolbar">
      <li class="clearfix">
        <a href="/archives" class="header-toolbar-left"><i class="fa fa-file-text"></i> Posts </a>
        <a href="/archives" class="header-toolbar-right"> 4 </a>
      </li>
      <li>
        <a href="/tags" class="header-toolbar-left"><i class="fa fa-tags"></i> Tags </a>
        <a href="/tags" class="header-toolbar-right"> 3 </a>
      </li>
      <li>
        <a href="/categories" class="header-toolbar-left"><i class="fa fa-folder-open"></i> Categories </a>
        <a href="/categories" class="header-toolbar-right"> 1 </a>
      </li>
    </ul>
    <h2 class="header-title">
      <i class="fa fa-book text-muted"></i>
      <a href="/">技术杂谈</a>
      
      
    </h2>
  </div>

  <div class="container">
    <div class="header-tab-wrapper clearfix">
      <span class="header-tab header-tab-selected"><i class="fa fa-thumbs-o-up"></i> Like</span>
      <span class="header-tab"><i class="fa fa-share-alt"></i> Share</span>
      <span class="header-tab"><i class="fa fa-comments-o"></i> Discussion</span>
      <span class="header-tab"><i class="fa fa-bookmark-o"></i> Bookmark </span>
      <span class="header-tab"><i class="fa fa-smile-o"></i> Smile <i class="fa fa-caret-down"></i></span>
    </div>
  </div>
</header>


<div class="post-container container">
  <h3>
    <i class="fa fa-user-o"></i>
    tudou

    <span class="post-date float-right" title="{{moment(1543576603000).format('MMM DD, YYYY, h:mm:ss A')}}">
      <i class="fa fa-pencil-square-o"></i>
      {{moment(1543576603000).fromNow()}}
    </span>
  </h3>

  <article class="post-content">
    <h1>cpu上下文切换</h1>
    <font color="red">大量等待CPU的进程调度也会导致平均负载升高，此时的CPU使用率也会升高。CPU的进程调度为什么会导致平均负载升高呢？</font>

<p>进程在竞争CPU的时候并没有真正运行，为什么还会导致系统的负载升高呢？==CPU上下文切换就是罪魁祸首==</p>
<p>我们都知道，Linux是一个多任务操作系统，它支持远大于CPU数量的任务同时运行。当然，这些任务并不是真正的同时运行，而是因为系统在很短的时间内，将==CPU轮流分配==给它们，造成多任务同时运行的错觉。</p>
<p>而在每个任务运行前，CPU都需要知道任务从哪里加载、又在哪里开始运行，也就是说，需要系统事先帮它设置好 <strong>CPU寄存器和程序计数器</strong>。</p>
<blockquote>
<p>CPU寄存器，是CPU内置的容量小、但速度极快的内存。而程序计数器，则是用来存储CPU正在执行的指令位置、或者即将执行的下一条指令位置。它们都是CPU在运行任何任务前必须的依赖环境，<strong>因此也被叫做CPU上下文。</strong></p>
</blockquote>
<blockquote>
<p>CPU上下文切换：就是先把前一个任务的CPU上下文（也就是CPU寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。</p>
</blockquote>
<p>而这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来。这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。</p>
<font color="red">CPU上下文切换无非就是更新了CPU寄存器的值，但这些寄存器，本身就是为了快速运行任务而设计的，为什么会影响系统的CPU性能呢？</font>

<p>在回答这个问题前，不知道你有没有想过，操作系统管理的这些”任务”到底是什么呢？</p>
<p>也许你会说，任务就是进程，或者说任务就是线程。是的，进程和线程是最常见的任务。但是除此之外呢？还有没有其他的任务呢？ <strong>硬件通过触发信号，会导致中断程序的调用，也是一种常见的任务</strong></p>
<p>所以 <font color="red">根据任务的不同</font>,CPU的上下文切换就可以分为几个不同的场景，也就是 <strong>进程上下文切换</strong>、<strong>线程上下文切换</strong>以及<strong>中断上下文切换</strong>。</p>
<font color="red">怎么理解这几个不同的上下文切换，以及它们为什么会引发CPU性能相关问题呢？</font>

<h3 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h3><p>Linux按照特权等级，把进程的运行空间分为内核空间和用户空间，分别对应着下图中，CPU特权等级的Ring0和Ring3。</p>
<ul>
<li>内核空间（Ring0）具有最高权限，可以直接访问所有资源</li>
<li>用户空间（Ring3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。</li>
</ul>
<p><img src="https://upload.cc/i1/2018/11/28/gnEYIw.png" alt="github" title="github"></p>
<p>换个角度看，也就是说，进程既可以在用户空间运行，又可以在内核空间中运行。进程在用户空间运行时，被称为进程的用户态，而陷入内核空间的时候，被称为进程的内核态。</p>
<p>从用户态到内核态的转变，需要通过 <strong>系统调用</strong>来完成。比如：当我们查看文件内容时，就需要多次系统调用来完成。首先调用open()打开文件，然后调用read()读取文件内容，并调用write()将内容写到标准输出，最后再调用close()关闭文件。</p>
<p>那么系统调用的过程中有没有发生CPU上下文的切换呢？答案是有！</p>
<p>CPU寄存器里原来用户态的指令位置，需要先保存起来。接着，为了执行内核态代码，CPU寄存器需要更新为内核态指令的新位置。最后才是跳到内核态运行内核任务。而系统调用结束后，CPU寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。<br>所以，<font color="red">一次系统调用的过程，其实是发生了两次CPU上下文切换</font>。</p>
<p>不过，需要注意的是，系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程。这里跟我们通常所说的进程上下文切换是不一样的：</p>
<ul>
<li>进程上下文切换，是指从一个进程切换到另一个进程运行</li>
<li>系统调用过程中一直是同一个进程在运行</li>
</ul>
<p>所以，系统调用过程通常称为特权模式切换，而不是上下文切换。但实际上，系统调用过程中，CPU的上下文切换还是无法避免的。</p>
<blockquote>
<p>进程上下文切换和系统调用又有什么区别呢？</p>
</blockquote>
<p>首先需要知道，进程是由内核来管理和调度的，进程的切换只发生在内核态。所以，进程的上下文不仅包括了虚拟内存、栈、全局变量等用户资源的空间，还包括了内核堆栈、寄存器等内核空间的状态。<br>因此：进程的上下文切换比系统调用时多了一步：在保存当前进程的内核状态和CPU寄存器之前，需要先把该进程的虚拟内存、栈等保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。</p>
<p>如下图所示，<strong>保存上下文和恢复上下问的过程并不是”免费的”，需要内核在CPU上运行才能完成。</strong></p>
<p><img src="https://upload.cc/i1/2018/11/28/aZSwFi.png" alt="contenxtSwitch" title="contenxtSwitch"></p>
<p>每次上下文切换都需要几十纳秒到数微妙的CPU时间。这个时间还是比较长的，特别是在进程上下文切换次数较多的情况下，很容易导致CPU将大量时间耗费在寄存器、内核栈以及虚拟内存等资源的保存和回复上，<br>进而大大缩短了真正运行进程的时间。这也是开头提到的，CPU上下文切换导致平均负载升高的一个重要因素。</p>
<p>另外：Linux通过TLB(Translation Lookaside Buffer)来管理虚拟内存到物理内存的映射关系。当虚拟内存更新后，TLB也需要刷新，内存的访问也会随之变慢。<br>特别是在多处理系统上，缓存是被多个处理器共享的，刷新缓存不仅会影响当前处理器的进程，还会影响共享缓存的其他处理器的进程。</p>
<font color="red"> 进程在什么时候才会被调度到CPU上运行呢？</font>

<p>最容易想到的一个时机，就是进程执行完终止了，它之前使用的CPU会释放出来，这个时候再从就绪队列里，拿一个新的进程来运行。除此以外，还有以下场景：</p>
<ol>
<li>为了保证所有进程可以得到公平调度，CPU被划分为一段段的时间片，这些时间片再被轮流分配给其他进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其他正在等待CPU的进程运行。</li>
<li>进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行</li>
<li>当进程通过睡眠函数sleep这样的方法将自己主动挂起时，自然也会被重新调度</li>
<li>当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行</li>
<li>发生硬件中断时，CPU上的进程会被中断挂起，转而执行内核中的中断服务程序</li>
</ol>
<p>了解这几个场景是很有必要的，因为一旦出现上下文切换的性能问题，它们就是幕后凶手</p>
<h3 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h3><p>线程与进程最大的区别在于，线程是调度的基本单位，而进程则是资源拥有的基本单位。也就是说，所谓内核中的任务调度，实际上的调度对象是线程，而进程只给线程提供了虚拟内存、全局变量<br>等资源。所以对于进程和线程，可以这么理解：</p>
<ul>
<li>当只有一个线程时，可以认为进程就等于线程</li>
<li>当进程拥有多个线程时，这么线程就会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的</li>
<li>线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的</li>
</ul>
<p>这么一来，线程的上下文切换其实就可以分为两种情况：</p>
<ol>
<li>前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样的</li>
<li>前后两个线程属于同一个进程。此时，虚拟内存是共享的。所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。</li>
</ol>
<p>所以说虽然同为上下文切换，但同进程内的线程切换，要比多进程间的切换消耗更少的资源，而这，也正是多线程代替多线程的一个优势</p>
<h3 id="中断上下文切换"><a href="#中断上下文切换" class="headerlink" title="中断上下文切换"></a>中断上下文切换</h3><p>除了前面两种上下文切换，还有一个场景也会切换CPU上下文，那就是中断。</p>
<p>为了快速响应硬件的事件，中断处理会打断进程的正常调度和运行，转而调用中断处理程序，响应设备事件。而在打断其他进程时，就需要将进程当前的状态保存下来，这样在中断结束后，进程仍然可以从原来的状态恢复运行。</p>
<p>跟进程上下文不同，中段上下文切换并不涉及到进程的用户态。所以，即便中断过程打断了一个正在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。中断上下文，其实只包括内核态中断服务<br>程序所必须的状态，包括CPU寄存器、内核堆栈、硬件中断参数等。</p>
<p>对同一个CPU来说，中断处理比进程拥有更高的优先级,所以中断上下文切换不会与进程上下文切换同时发生。同样道理，由于中断会打断正常进程的调度和执行，所以大部分中断处理程序都短小精悍，以便尽可能快的执行结束。</p>
<p>另外，跟进程上下文切换一样，中断上下文切换也需要消耗CPU,切换次数过多也会消耗大量的CPU,甚至降低系统的整体性能。所以，当你发现中断次数过多时，就需要注意排查它是否会给你的系统打来严重的性能问题。</p>
<blockquote>
<p>CPU上下文切换，是保证Linux系统正常工作的核心功能之一，一般情况下不需要我们特别关注。<br>但过多的上下文切换，会把CPU时间消耗在寄存器、内核栈以及虚拟内存等数据的保存和恢复上，进而缩短进程真正运行的时间，导致系统的整体性能大幅下降。</p>
</blockquote>
<h3 id="怎么查看系统的上下文切换情况"><a href="#怎么查看系统的上下文切换情况" class="headerlink" title="怎么查看系统的上下文切换情况"></a>怎么查看系统的上下文切换情况</h3><p>过多的上下文切换，会把CPU时间消耗在寄存器、内核栈以及虚拟内存等数据的保存和恢复上，缩短进程真正运行的时间，成为系统性能大幅下降的一个元凶。<br>linux系统中可以使用vmstat这个工具，来查询系统的上下文切换情况。</p>
<p>vmstat是一个常用的系统性能分析工具，主要用来分析系统的内存使用情况，也常用来分析CPU上下文切换和中断的次数。</p>
<p>例如下面的vmstate使用示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 每隔 5 秒输出 1 组数据</span><br><span class="line">$ vmstat 5</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 0  0      0 7005360  91564 818900    0    0     0     0   25   33  0  0 100  0  0</span><br></pre></td></tr></table></figure>
<p><img src="https://upload.cc/i1/2018/11/29/MH3QxU.png" alt="vmstat" title="vmstat"><br>每列含义如下(重点关注 cs in r b)：</p>
<p><strong>Procs</strong></p>
<ul>
<li><font color="red">r(Running or Runnable):就绪队列的长度，也就是正在运行和等待CPU的进程数</font></li>
<li><font color="red">b(blocked):处于不可中断睡眠状态的进程数。</font>

</li>
</ul>
<p><strong>Memory</strong></p>
<ul>
<li>swpd:</li>
<li>free:空闲的内存空间</li>
<li>buff:已使用的buff大小，对块设备的读写进行缓存</li>
<li>cache:已使用的cache大小，文件系统的cache</li>
<li>incat:非活跃内存的大小 (-a参数)</li>
<li>active:活跃内存的大小(-a参数)</li>
</ul>
<p><strong>swap</strong></p>
<ul>
<li>si:内存交换，由磁盘调入内存</li>
<li>so:内存交换，由内存调入磁盘</li>
</ul>
<p><strong>IO</strong></p>
<ul>
<li>bi:从block设备读入的数据总量(读磁盘)(KB/s)</li>
<li>bo:写入到block设备的数据总量（写磁盘)(KB/s)</li>
</ul>
<p><strong>System</strong></p>
<ul>
<li><font color="red">in:每秒上下文切换的次数</font></li>
<li><font color="red">cs:每秒中断的次数</font>

</li>
</ul>
<p><strong>CPU</strong></p>
<ul>
<li>us:用户进程消耗的CPU的时间百分比</li>
<li>sy:内核进程消耗的CPU的时间百分比</li>
<li>id:空闲</li>
<li>wa:IO等待消耗的CPU时间百分比</li>
</ul>
<p>vmstat只给出了系统总体的上下文切换情况，要想查看每个进程的详细情况，就需要使用pidstat了。给它加上 -w选项，就可以查看每个进程上下文切换的情况了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 每隔 5 秒输出 1 组数据</span><br><span class="line">$ pidstat -w 5</span><br><span class="line">Linux 4.15.0 (ubuntu)  09/23/18  _x86_64_  (2 CPU)</span><br><span class="line"></span><br><span class="line">08:18:26      UID       PID   cswch/s nvcswch/s  Command</span><br><span class="line">08:18:31        0         1      0.20      0.00  systemd</span><br><span class="line">08:18:31        0         8      5.40      0.00  rcu_sched</span><br></pre></td></tr></table></figure>
<p>有两列是需要重点关注的。一个是cswch/s，表示每秒自愿上下文切换(voluntary context switches)的次数。<br>另一个是nvcswch/s,表示每秒非自愿上下文切换(non voluntary context switches)的次数。<br>这是两个比较重要的概念，他们意味着不同的性能问题：</p>
<ul>
<li>自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换。比如说，I/O、内存等资源不足时，就会发生自愿上下文切换</li>
<li>非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如说，大量进程都在抢占CPU时，就容易发生非自愿上下文切换。</li>
</ul>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><p>先用vmstat看一下空闲系统的上下文切换次数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 间隔 1 秒后输出 1 组数据</span><br><span class="line">$ vmstat 1 1</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 0  0      0 6984064  92668 830896    0    0     2    19   19   35  1  0 99  0  0</span><br></pre></td></tr></table></figure>
<p>这里可以看到，现在的上下文切换次数cs是35，中断次数in是19，r和b都是0。因为没有其他任务，所以他们就是空闲系统的上下文切换次数。</p>
<p><strong>操作和分析</strong><br>首先，在第一个终端里运行 sysbench,模拟多线程调度的瓶颈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 以 10 个线程运行 5 分钟的基准测试，模拟多线程切换的问题</span><br><span class="line">$ sysbench --threads=10 --max-time=300 threads run</span><br></pre></td></tr></table></figure>
<p>接着，在第二个终端运行vmstat,观察上下文切换情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 每隔 1 秒输出 1 组数据（需要 Ctrl+C 才结束）</span><br><span class="line">$ vmstat 1</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 6  0      0 6487428 118240 1292772    0    0     0     0 9019 1398830 16 84  0  0  0</span><br><span class="line"> 8  0      0 6487428 118240 1292772    0    0     0     0 10191 1392312 16 84  0  0  0</span><br></pre></td></tr></table></figure>
<p>从上图可以看出，cs列的上下文切换次数从35骤然上升到139万。同时，观察其他几个指标：</p>
<ul>
<li>r列：就绪队列的长度达到了8，远远超过了系统CPU的个数2，所以肯定会有大量的CPU竞争</li>
<li>us(user) 和 sy(system)列：这两列的CPU使用率加起来上升到了100%，其中系统CPU使用，也就是sy列高达84%，说明CPU主要是被内核占用了</li>
<li>in列：中断次数也上升到了1万左右，说明中断处理也是个潜在的问题</li>
</ul>
<p>综合这几个指标，我们可以知道，系统的就绪队列过长，也就是正在运行和等待CPU的进程数过多，导致了大量的上下文切换，而上下文切换又导致了系统CPU的占用率升高</p>
<p>那么到底是什么进程导致了这些问题呢？</p>
<p>在第三个终端再用pidstat来看一下，CPU和进程上下文的切换情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 每隔 1 秒输出 1 组数据（需要 Ctrl+C 才结束）</span><br><span class="line"># -w 参数表示输出进程切换指标，而 -u 参数则表示输出 CPU 使用指标</span><br><span class="line">$ pidstat -w -u 1</span><br><span class="line">08:06:33      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command</span><br><span class="line">08:06:34        0     10488   30.00  100.00    0.00    0.00  100.00     0  sysbench</span><br><span class="line">08:06:34        0     26326    0.00    1.00    0.00    0.00    1.00     0  kworker/u4:2</span><br><span class="line"></span><br><span class="line">08:06:33      UID       PID   cswch/s nvcswch/s  Command</span><br><span class="line">08:06:34        0         8     11.00      0.00  rcu_sched</span><br><span class="line">08:06:34        0        16      1.00      0.00  ksoftirqd/1</span><br><span class="line">08:06:34        0       471      1.00      0.00  hv_balloon</span><br><span class="line">08:06:34        0      1230      1.00      0.00  iscsid</span><br><span class="line">08:06:34        0      4089      1.00      0.00  kworker/1:5</span><br><span class="line">08:06:34        0      4333      1.00      0.00  kworker/0:3</span><br><span class="line">08:06:34        0     10499      1.00    224.00  pidstat</span><br><span class="line">08:06:34        0     26326    236.00      0.00  kworker/u4:2</span><br><span class="line">08:06:34     1000     26784    223.00      0.00  sshd</span><br></pre></td></tr></table></figure>
<p>从pidstat的输出可以发现，CPU的升高果然是由sysbench导致的，它的CPU使用率已经达到了100%。但上下文切换则是来自其他进程，包括非自愿切换频率最高的pidstat,<br>以及自愿切换频率最高的 kworker和sshd。不过这个pidstat输出的上下文切换次数，加起来就几百，比vmstat的139万明显小了很多。这是怎么回事呢？</p>
<p><strong>Linux调度的基本单位是线程，而我们场景模拟的sysbench模拟的也是线程调度问题，那么，pid是不是忽略了线程的数据呢？</strong></p>
<blockquote>
<p>pid默认显示进程的指标数据，加上 -t参数后,才会输出线程的指标。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 每隔 1 秒输出一组数据（需要 Ctrl+C 才结束）</span><br><span class="line"># -wt 参数表示输出线程的上下文切换指标</span><br><span class="line">$ pidstat -wt 1</span><br><span class="line">08:14:05      UID      TGID       TID   cswch/s nvcswch/s  Command</span><br><span class="line">...</span><br><span class="line">08:14:05        0     10551         -      6.00      0.00  sysbench</span><br><span class="line">08:14:05        0         -     10551      6.00      0.00  |__sysbench</span><br><span class="line">08:14:05        0         -     10552  18911.00 103740.00  |__sysbench</span><br><span class="line">08:14:05        0         -     10553  18915.00 100955.00  |__sysbench</span><br><span class="line">08:14:05        0         -     10554  18827.00 103954.00  |__sysbench</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>从上面可以看到，虽然sysbench进程的上下文切换次数看起来并不多，但它的子线程的上下文切换次数却有很多。看来，上下文罪魁祸首，还是过多的sysbench线程。</p>
<p>还记得吗？在观察系统指标时，除了上下文切换频率骤然升高，还有一个指标也有很大的变化。是的，中断次数！中段次数也上升到了1万，那么 <strong>到底是什么类型的中断上升了呢？</strong></p>
<p>我们知道，中断发生在内核态，而pidstat只是一个进程的性能分析工具，并不提供任何关于中断的详细信息，怎样才能知道中断发生了的类型呢？</p>
<p>我们可以从 /proc/interrupts这个只读文件中读取。/proc 实际上是Linux的一个虚拟文件系统，用户内核态和用户空间之间的通信。 /proc/interrupts就是这种通信机制的一部分，提供了一个只读的中断使用情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># -d 参数表示高亮显示变化的区域</span><br><span class="line">$ watch -d cat /proc/interrupts</span><br><span class="line">           CPU0       CPU1</span><br><span class="line">...</span><br><span class="line">RES:    2450431    5279697   Rescheduling interrupts</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>观察一段时间，发现变化速度最快的是重调度中断(RES)，这个中断类型表示：<strong>唤醒空闲状态的CPU来调度新的执行任务</strong>。<br>这是多任务处理系统中，调度器用来分散任务到不同CPU的机制，通常也被称为<strong>处理器中断（Inter-Processor Interrupts,IPI）</strong></p>
<p><strong>所以，这里的中断升高还是因为多任务的调度问题，跟前面上下文切换次数的分析结果是一致的</strong></p>
<font color="red">每秒上下文切换多少次才算正常呢</font>

<p><strong>这个问题取决于系统本身的CPU性能</strong>。如果系统的上下文切换次数比较稳定，那么数百到一万以内，都应该算是正常的。但当上下文切换次数超过一万次，或者切换次数出现数量级的增长时，就很可能出现了性能问题。<br>这是需要根据上下文切换的类型，再做具体分析。比方说：</p>
<ul>
<li>自愿上下文切换次数变多了，说明进程都在等待资源，有可能发生I/O等其他问题</li>
<li>非资源上下文次数变多了，说明进程都在被强制调度，也就是都在抢占CPU，说明CPU成了瓶颈</li>
<li>中断次数变多了，说明CPU被中断处理程序占用，还需要查看 /proc/interrupts文件来分析具体的中断类型</li>
</ul>

  </article>
</div>


    




</div>

<div class="footer-wrapper container">
  <footer class="footer clearfix">
    <div class="clearfix">
    <a href="http://wanggaoliang.club" class="footer-logo">
      <i class="fa fa-github"></i>
    </a>
    <ul class="footer-social-link">
      <li>© 2018 tudou</li>
      <li><a href="http://wanggaoliang.club">Home</a></li>
      
    </ul>
    <div class="footer-theme-info">
      Theme <a href="//github.com/sabrinaluo/hexo-theme-replica">Replica</a>
      by <a href="//github.com/sabrinaluo">Hiitea</a> ❤ Powered by Hexo
    </div>
    </div>
    
  </footer>
</div>




<script src="/js/main.js"></script>

</body>
</html>
